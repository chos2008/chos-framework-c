

#include <stdio.h>
#include <windows.h>
#include <string>
using namespace std;
#include <MMSYSTEM.H>
#include <tchar.h>
#pragma   comment(lib, "winmm.lib")

#include "D:\home\admin\workstation\c\HIB_DLog\DLog.h"

LPWAVEHDR lpWaveHeader;
int i = 0;


void pa(LPHWAVEIN phwi) {
	
	HWAVEIN _hwi = *phwi;
	//LPUINT puDeviceID;
	UINT _uDeviceID = 0;
	printf("uDeviceID: %d\n", _uDeviceID);
	MMRESULT m = waveInGetID(_hwi, &_uDeviceID);
	printf("waveInGetID: %d\n", m);
	printf("uDeviceID: %d\n", _uDeviceID);


	//char*
	LPSTR buffer = (LPSTR) malloc(/*100 * 1024 * */1024 * sizeof(char));
	//GlobalAllocPtr(GHND o r GM EM SHARE, 1024) ;
	//GlobalAllocPtr
	lpWaveHeader = (LPWAVEHDR) malloc(sizeof(WAVEHDR));
	lpWaveHeader->dwFlags = 0;
	lpWaveHeader->lpData = buffer;
	lpWaveHeader->dwBufferLength = /*100 * 1024 * */1024;
	
	m = waveInPrepareHeader(_hwi, lpWaveHeader, sizeof(WAVEHDR));
	printf("waveInPrepareHeader: %d\n", m);

	m = waveInAddBuffer(_hwi, lpWaveHeader, sizeof(WAVEHDR));
	printf("waveInAddBuffer: %d\n", m);
}


void CALLBACK waveInProc(HWAVEIN hwi,    //声音输入设备句柄
	UINT uMsg,      //产生的消息，由系统给出
	DWORD dwInstance,//在waveinopen中给出要传递给该函数的数据
	DWORD dwParam1, //附加数据１
	DWORD dwParam2  //附加数据２
	) {

	printf("................\n");
	printf("hwi................%d\n", hwi);
	printf("uMsg................%d\n", uMsg);
	printf("dwInstance................%d\n", dwInstance);
	printf("dwParam1................%d\n", dwParam1);
	printf("dwParam2................%d\n", dwParam2);
	printf("................\n");

	if (uMsg == WIM_OPEN) {
		printf("Voice device opened...\n");
	} else if (uMsg == WIM_CLOSE) {
		printf("Voice device closed...\n");
	} else if (uMsg == WIM_DATA) {
		printf("Buffer fulled...\n");
		LPWAVEHDR lpWaveHeader1 = (LPWAVEHDR) dwParam1;

		/*
		char* a = "abcdef";
		printf("aaaa: %d\n", sizeof(a));
		printf("aaaa: %d\n", sizeof(*a));
		printf("aaaa: %d\n", strlen(a));
		*/


		printf("------:%s\n", lpWaveHeader1->lpData);
		printf("------:%d\n", strlen(lpWaveHeader1->lpData));

		MMIOINFO mmioinfo;
		HMMIO hmmio = NULL;
		hmmio = mmioOpen("c:\\voice1.wav", NULL, MMIO_CREATE | MMIO_WRITE);
		//hmmio = mmioOpen(_T("c:\\voice0.wav"), NULL, MMIO_WRITE);
		if (hmmio == NULL) {
			printf("Open file fail...\n");
			exit(0);
		}
		mmioWrite(hmmio, lpWaveHeader1->lpData, strlen(lpWaveHeader1->lpData));
		mmioFlush(hmmio, MMIO_EMPTYBUF);
		mmioClose(hmmio, MMIO_FHOPEN);
		
		
		MMRESULT m = waveInUnprepareHeader(hwi, lpWaveHeader1, sizeof(WAVEHDR));
		printf("waveInUnprepareHeader: %d\n", m);

		pa(&hwi);
		//*/

		//printf("................\n");
		//FILE *f = fopen("c:\\voice0.dat", "wb");
		//fputs(lpWaveHeader1->lpData, f);
	}
}




DWORD WINAPI pthread_callback(LPVOID args) {


	//char* e = (char*) args;
	DWORD ret = 0;


	LPHWAVEIN phwi = (LPHWAVEIN) malloc(sizeof(HWAVEIN));
	//HWAVEIN hwi;

	//#define      WAVE_MAPPER     ((UINT)-1)
	//WAVE_MAPPER  The function selects a waveform-audio input device capable 
	//             of recording in the specified format.
	UINT uDeviceID = WAVE_MAPPER;

    //LPCWAVEFORMATEX pwfx;
	WAVEFORMATEX pwfx;
	pwfx.wFormatTag = WAVE_FORMAT_PCM; //#define WAVE_FORMAT_PCM     1
	pwfx.nChannels = 1;
	//pwfx.
	pwfx.wBitsPerSample = 8;
	pwfx.nSamplesPerSec = 11025L;
	pwfx.nBlockAlign = 1;
	pwfx.nAvgBytesPerSec = 11025L;
	pwfx.cbSize = 0;

	// see callback function <b>waveInProc</b> definitions for details.
	DWORD dwCallback = (DWORD) waveInProc;

	// user define
	// the third parameter dwInstance of callback function <b>dwCallback</b>
	DWORD dwInstance = 1000;

	//#define CALLBACK_FUNCTION   0x00030000l    /* dwCallback is a FARPROC */
	//#define CALLBACK_NULL       0x00000000l    /* no callback */
	//#define  WAVE_FORMAT_QUERY         0x0001
	DWORD fdwOpen = CALLBACK_FUNCTION;

	//typedef UINT        MMRESULT;
	MMRESULT d = waveInOpen(phwi, uDeviceID, &pwfx, dwCallback, dwInstance, fdwOpen);
	printf("waveInOpen: %d\n", d);
	printf("HWAVEIN: %d\n", *phwi);

	switch (d) {
	    case MMSYSERR_NOERROR: 
			//DWORD dd = MMSYSERR_NOERROR;
			printf("MMSYSERR_NOERROR: %d, %s\n", d, &"no error, Success.");
			break;

		case MMSYSERR_ERROR: 
			printf("MMSYSERR_ERROR: %d, %s", d, &"unspecified error");
			break;

		case MMSYSERR_ALLOCATED:
			printf("MMSYSERR_ALLOCATED: %d, %s", d, &"Specified resource is already allocated.");
			break;

		case MMSYSERR_INVALPARAM:
			printf("MMSYSERR_INVALPARAM: %d, %s\n", d, "invalid parameter passed");
			break;

		case MMSYSERR_BADDEVICEID:
			printf("MMSYSERR_BADDEVICEID: %d, %s", d, &"Specified device identifier is out of range.");
			break;

		case MMSYSERR_NODRIVER:
			printf("MMSYSERR_NODRIVER: %d, %s", d, &"No device driver is present.");
			break;

		case MMSYSERR_NOMEM:
			printf("MMSYSERR_NOMEM: %d, %s", d, &"Unable to allocate or lock memory.");
			break;

		case WAVERR_BADFORMAT:
			printf("WAVERR_BADFORMAT: %d, %s\n", d, "Attempted to open with an unsupported waveform-audio format.");
			break;

		default: 
			printf("default: %d, %s\n", d, "default.");
			
	};


	pa(phwi);
	
	HWAVEIN _hwi = *phwi;
	MMRESULT m = waveInStart(_hwi);
	printf("waveInStart: %d\n", m);


	return ret;

}



void at(char* home) {
	string tname = "Thread-Echo Service";
	DWORD threadID;
	CreateThread(NULL, 0, pthread_callback, home, 0, &threadID);

	string log = "";
	log = log + "Thread ";
	log = log + tname;
	log = log + " #";
	char* a = (char*) malloc(4 * sizeof(char));
	itoa(threadID, a, 10);
	log = log + a;
	log = log + " starting...\n";
	//logdebug("Thread ??? started...\n");
	logdebug(log.c_str());
}


void main() {
	
	UINT n = waveInGetNumDevs();
	printf("waveInGetNumDevs: %d\n", n);

	at("");
	ExitThread(0);
}